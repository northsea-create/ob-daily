# Python

## 函数


| 操作类别               | 描述                   | `str` (字符串)                                | `list` (列表)                                            | `tuple` (元组)               | `dict` (字典)                               | `set` (集合)                                   | `pandas.Series`                                       | `pandas.DataFrame`                                     | `openpyxl.workbook.Workbook` / `openpyxl.worksheet.worksheet.Worksheet` / `openpyxl.cell.cell.Cell`                     |         |
| :----------------- | :------------------- | :----------------------------------------- | :----------------------------------------------------- | :------------------------- | :---------------------------------------- | :------------------------------------------- | :---------------------------------------------------- | :----------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------- | ------- |
| **创建/加载**          | 初始化/打开对象             | `"abc"`, `str(123)`                        | `[1,2]`, `list("ab")`                                  | `(1,2)`, `tuple([1,2])`    | `{'a':1}`, `dict(a=1)`                    | `{1,2}`, `set([1,2])`                        | `pd.Series([1,2])`                                    | `pd.DataFrame({'col1':[1,2]})`                         | `wb = openpyxl.Workbook()`, `wb = openpyxl.load_workbook('file.xlsx')`, `ws = wb.active`, `ws = wb.create_sheet('New')` |         |
| **访问元素/内容**        | 获取单个或部分元素/单元格内容      | `s[i]`, `s[i:j]`                           | `l[i]`, `l[i:j]`                                       | `t[i]`, `t[i:j]`           | `d[key]`, `d.get(key)`                    | (不直接按索引) `item in s`                         | `ser[label/pos]`, `ser.loc[]`, `ser.iloc[]`           | `df[col]`, `df.loc[]`, `df.iloc[]`                     | `ws['A1'].value`, `ws.cell(row=1, column=1).value`, `for row in ws.iter_rows(): ...`, `ws.title` (sheet名)               |         |
| **长度/大小**          | 获取元素/工作表数量/行列数       | `len(s)`                                   | `len(l)`                                               | `len(t)`                   | `len(d)` (键值对数量)                          | `len(s)`                                     | `len(ser)`, `ser.size`, `ser.shape`                   | `len(df)` (行数), `df.size`, `df.shape`                  | `len(wb.sheetnames)` (sheet数), `ws.max_row`, `ws.max_column`, `ws.dimensions` (有数据的范围)                                  |         |
| **迭代**             | 遍历元素/行/单元格           | `for char in s:`                           | `for item in l:`                                       | `for item in t:`           | `for key in d:`, `for k,v in d.items():`  | `for item in s:`                             | `for val in ser:`, `for idx,val in ser.items():`      | `for col_name in df:`, `for idx,row in df.iterrows():` | `for sheet in wb:`, `for row_cells in ws.rows:`, `for cell_obj in row_cells:`, `ws.iter_rows()`, `ws.iter_cols()`       |         |
| **成员检查**           | 判断元素/Sheet是否存在       | `sub in s` (子串)                            | `item in l`                                            | `item in t`                | `key in d` (检查键)                          | `item in s`                                  | `val in ser.values`, `label in ser.index`             | `val in df[col].values`, `col_name in df.columns`      | `'SheetName' in wb.sheetnames`, (单元格内容检查需迭代)                                                                            |         |
| **添加元素/Sheet/行/列** | 增加新内容                | (不可变, 用 `+` 创建新串)                          | `l.append(x)`, `l.insert(i,x)`, `l.extend(iter)`       | (不可变)                      | `d[key]=val`, `d.update(other)`           | `s.add(x)`, `s.update(iter)`                 | `ser.append(other_ser)` (返回新Series)                   | `df[new_col]=vals`, `df.loc[new_idx]=vals`             | `ws = wb.create_sheet('New')`, `ws.append([val1,val2])` (追加行), `ws.insert_rows(idx)`, `ws.insert_cols(idx)`             |         |
| **删除元素/Sheet/行/列** | 移除内容                 | (不可变, 用切片创建新串)                             | `l.remove(val)`, `l.pop(idx)`, `del l[idx/slice]`      | (不可变)                      | `d.pop(key)`, `del d[key]`, `d.popitem()` | `s.remove(val)`, `s.discard(val)`, `s.pop()` | `ser.drop(labels)` (返回新Series)                        | `df.drop(labels, axis=0/1)` (返回新DataFrame)             | `wb.remove(ws_object)` 或 `del wb['SheetName']`, `ws.delete_rows(idx, amount)`, `ws.delete_cols(idx, amount)`            |         |
| **修改元素/单元格值**      | 改变现有内容的值             | (不可变)                                      | `l[i] = new_val`                                       | (不可变)                      | `d[key] = new_val`                        | (集合元素本身不可变，但可增删)                             | `ser[label/pos]=new_val`, `ser.loc[]=new_val`         | `df.loc[row,col]=new_val`, `df.iloc[]=new_val`         | `ws['A1'] = new_val`, `ws.cell(row=1, col=1, value=new_val)`                                                            |         |
| **查找/索引**          | 找到元素位置/Sheet对象/单元格对象 | `s.find(sub)`, `s.index(sub)`              | `l.index(val)`                                         | `t.index(val)`             | (通过键直接访问)                                 | (无索引)                                        | `ser.get(label)`, (通过标签/位置访问)                         | (通过行列标签/位置访问)                                          | `ws = wb['SheetName']`, `cell = ws['A1']`, `cell = ws.cell(row,col)`                                                    |         |
| **计数**             | 统计出现次数/Sheet数量       | `s.count(sub)`                             | `l.count(val)`                                         | `t.count(val)`             | (需手动遍历 `d.values()`)                      | (无，元素唯一)                                     | `ser.value_counts()`                                  | `df[col].value_counts()`                               | `len(wb.sheetnames)` (Sheet数), (单元格值计数需迭代)                                                                              |         |
| **排序**             | 按顺序排列/Sheet顺序        | `sorted(s)` (返回列表)                         | `l.sort()` (原地), `sorted(l)` (返回新列表)                   | `sorted(t)` (返回列表)         | `sorted(d.items())` (按键排序键值对)             | `sorted(s)` (返回列表)                           | `ser.sort_values()`, `ser.sort_index()`               | `df.sort_values(by=col)`, `df.sort_index()`            | (Sheet顺序可通过 `wb.move_sheet()` 调整，数据排序通常由Pandas处理后再写入)                                                                   |         |
| **复制**             | 创建副本/复制Sheet         | `new_s = s`, `s[:]` (效果一样)                 | `l.copy()`, `l[:]` (浅拷贝)                               | `new_t = t`, `t[:]` (效果一样) | `d.copy()` (浅拷贝)                          | `s.copy()` (浅拷贝)                             | `ser.copy()`                                          | `df.copy()`                                            | `target_ws = wb.copy_worksheet(source_ws)`                                                                              |         |
| **字符串操作**          | 针对字符串的特殊处理           | (自身就是) `.upper()`, `.split()`, `.strip()`等 | (对元素需迭代) `[x.upper() for x in l if isinstance(x,str)]` | (同列表)                      | (对键或值需迭代)                                 | (对元素需迭代)                                     | `ser.str.*` (如 `.str.upper()`, `.str.split()`)        | `df[col].str.*` (对字符串列)                                | (单元格值是字符串时，可取出后用Python str方法处理)                                                                                         |         |
| **数学/统计**          | 计算总和、平均值等            | (不直接适用)                                    | `sum(l)`, (需 `numpy` 或 `pandas` 做更复杂统计)                | `sum(t)`, (同列表)            | (对值需迭代 `sum(d.values())`)                 | `sum(s)`, (同列表)                              | `ser.sum()`, `ser.mean()`, `ser.std()`, `.describe()` | `df.sum()`, `df.mean()`, `df.describe()` (按列)          | (openpyxl 本身不做统计，可读取数据到Pandas处理；支持写入公式 `ws['C1'] = '=SUM(A1:B1)'`)                                                      |         |
| **集合运算**           | 交集、并集、差集             | (不直接适用)                                    | (需手动实现或转set)                                           | (需手动实现或转set)               | (对键可转set：`d1.keys() & d2.keys()`)         | `s1 & s2`, `s1                               | s2`, `s1 - s2`, `s1 ^ s2`                             | (对索引或值可转set)                                           | (对索引或列值可转set)                                                                                                           | (不直接适用) |
| **分组聚合**           | 按类别汇总数据              | (不直接适用)                                    | (需复杂手动逻辑)                                              | (需复杂手动逻辑)                  | (需复杂手动逻辑)                                 | (不直接适用)                                      | `ser.groupby(keys).agg_func()`                        | `df.groupby(by_cols).agg_func()`                       | (数据分析任务通常交给Pandas)                                                                                                      |         |
| **合并/连接**          | 将多个对象/Sheet内容组合      | `s1 + s2` (拼接)                             | `l1 + l2` (拼接), `l1.extend(l2)`                        | `t1 + t2` (拼接)             | `d1.update(d2)`                           | `s1.update(s2)` (并集并修改)                      | `pd.concat([s1,s2])`                                  | `pd.concat([df1,df2])`, `pd.merge(df1,df2)`            | (需手动迭代读取多个Sheet的数据，再用Python或Pandas合并)                                                                                   |         |
| **保存/写入**          | 将数据持久化               | `with open('f.txt','w') as f: f.write(s)`  | (需序列化，如json, pickle)                                   | (同列表)                      | (同列表)                                     | (同列表)                                        | `ser.to_csv()`, `ser.to_excel()` (需DataFrame)         | `df.to_csv()`, `df.to_excel()`                         | `wb.save('filename.xlsx')`                                                                                              |         |
| **样式/格式**          | 设置外观                 | (不适用)                                      | (不适用)                                                  | (不适用)                      | (不适用)                                     | (不适用)                                        | (通常通过Pandas写入Excel时的参数或结合openpyxl)                    | (同Series)                                              | `cell.font`, `cell.fill`, `cell.alignment`, `cell.number_format`, `ws.column_dimensions['A'].width`                     |         |



## 读取操作

|           | 读取                                                                                                                                                                                                                                                | 写入                                                                        |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| TXT       | with open('file.txt','r',encoding='utf-8) as f:<br>content=f.read()    ---这样会自动关闭<br>--- 或逐行读取<br>for line in f:<br>print(line.strip())                                                                                                           | with open('output.txt','w',encoding='utf-8') as f:<br>f.write('第一行文本,\n') |
| PANDAS    | import pandas as pd<br>df=pd.read_excel('data.xlsx', sheet_name=None)                                                                                                                                                                             | df.to_dxcel('output.xlsx', index=False, sheet_name='Sheet1')              |
| OPENPYXL  | import openpyxl as op<br>wb=load_workbook('data.xlsx')<br>ws=workbook['sheet1']<br>cell=sheet['sheet1'].value<br>遍历工作表中的行和单元格<br>for row in sheet.iter_rows(min_row=1, max_row=2, min_col=1, max_col=2):<br>for cell in row:<br>print(cell.value) | 先赋值<br>再保存<br>output.save('output.xlsx')                                  |
| cypher（图） | load csv with headers `from` 'file:// data.csv' as row<br>merge (p:person{name:row.name, age:row.age})<br>merge (c:company{cname:row.cname})<br>merge (a)-[friend:row.friend]->(b)                                                                |                                                                           |

## 删除
| 类型     | 常用删除方法/关键字                            | 说明                                                                  |
| :----- | :------------------------------------ | :------------------------------------------------------------------ |
| `set`  | `remove(value)`                       | 按值移除，值不存在时报错 `KeyError`。                                            |
|        | `discard(value)`                      | 按值移除，值不存在时不报错。**（推荐）**                                              |
|        | `pop()`                               | 移除并返回任意一个元素，空集合报错 `KeyError`。                                       |
| `dict` | `pop(key[, default])`                 | 按键移除并返回值，键不存在时：有default返default，无则报错 `KeyError`。**（推荐，可提供默认值避免报错）** |
|        | `del dict[key]`                       | 按键移除，键不存在时报错 `KeyError`。                                            |
| `list` | `remove(value)`                       | 按值移除第一个匹配项，值不存在时报错 `ValueError`。                                    |
|        | `pop([index])`                        | 按索引移除并返回值，索引不存在或空列表报错 `IndexError`。                                 |
|        | `del list[index]` 或 `del list[slice]` | 按索引或切片移除，索引不存在报错 `IndexError`。                                      |


df['']


# 神通数据库
## **DQL：查询** 上机+笔试 核心考点
查了几条数据

### 1. 单表查询

### 2. 连接查询
- 交叉连接 CROSS JOIN
- 内连接 INNER JOIN/JOIN
	- 特点：结果集==不包含==未匹配行
	- 分类
		- 一般内连接
		- 自连接
	- 连接条件
		- ON
		- USING(a,b): 指定同名列
		- NATURAL: 自动查找所有同名列
- 外连接 LEFT/RIGHT/FULL (OUTER) JOIN 
	- 特点：结果集中==包含==不匹配行

### 3. 子查询
- IN 子查询：左右列数量需一致
- EXISTS 子查询：常与select 1 配合使用，当作信号灯     ***迭代业务场景代码块***
	 ```SQL
 SELECT * 
 FROM LOAN a
 WHERE EXISTS (SELECT 1 FROM LOAN 
 				WHERE CNO=a.CNO                  ---可以引用源表
 				HAVING AVG(LAMOUNT)>a.LAMOUNT);	 ---这里写需要找的判断值
 				```
		
- 比较运算符子查询 ==（使用比较运算符的子查询只能返回一列）==
	 ```SQL
 SELECT * 
 FROM client
 WHERE cincome > (SELECT AVG(cincome) FROM client 
 				WHERE cjob='医生');	 ---直观感觉：右边比较值固定的时候，且代替开窗（不用额外储存值）
 				```

- 其他子查询
	- 子查询可以作为一般表达式，此时子查询必须==返回``单一值``或``单个列值列表``==
	- FROM子句中嵌入子查询：子查询常在WHERE/HAVING/FROM中，在FROM里嵌入时，可以作为``内嵌视图``使用
	- 可以在INSERT/UPDATE/DELETE中使用

### 4. 操作符、函数
开窗函数、时间等类型转换、case when表达式
[[SQL 业务场景常见代码块]] 
[[SQL 时间函数]]




## **DDL、DCL：** 创建 控制 权限
建表、约束、主键、修改、删除
权限、控制、创建、修改、删除


## **数据库存储** ：体系结构+存储管理
物理存储、逻辑存储（结构+如何存储）
备份与恢复
不同格式文件如何导入数据库

